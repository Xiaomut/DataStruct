# 1. 概述

## 1.1 分类
- `比较类排序: `通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此也称为非线性时间比较类排序。
- `非比较类排序: `不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。 

<div align="center"><img src="./assets/排序总览图.png" width="60%"></div>

## 1.2 复杂度及稳定性

<div align="center"><img src="./assets/排序复杂度及稳定性.png" width="60%"></div>


# 2. 排序算法
## 2.1 冒泡排序 (Bubble Sort)

<div align="center"><img src="./assets/冒泡排序.gif" width="80%"></div>

- Python 版
```py
def bubbleSort(array):
    n = len(array)
    for i in range(n):
        flag = True    # 标记
        for j in range(1, n - i):
            if array[j] < array[j-1]:
                array[j], array[j-1] = array[j-1], array[j]
                flag = False
        # 某一趟遍历如果没有数据交换，则说明已经排好序了，因此不用再进行迭代了
        if flag:    
            break
    return array
```

- Golang 版
```go
func bubbleSort(array []int) []int {
    for i := 0; i < len(array); i++ {
        flag := true
        for j := 0; j < len(array)-i-1; j++ {
            if array[j] > array[j+1] {
                array[j], array[j+1] = array[j+1], array[j]
                flag = false
            }
        }
        if flag {
            break
        }
    }
    return array
}
```

- `最好情况: ` 我们只需要进行一次冒泡操作，没有任何元素发生交换，此时就可以结束程序，所以最好情况时间复杂度是O(n).
- `最坏情况: ` 要排序的数据完全倒序排列的，我们需要进行n次冒泡操作，每次冒泡时间复杂度为O(n),所以最坏情况时间复杂度为O(n^2)
- `平均复杂度: ` `O(n^2)`
- `原地排序: ` 冒泡的过程只涉及相邻数据之间的交换操作而没有额外的内存消耗，故冒泡排序为原地排序算法。
- `稳定排序: ` 在冒泡排序的过程中，只有每一次冒泡操作才会交换两个元素的顺序。所以我们为了冒泡排序的稳定性，在元素相等的情况下，我们不予交换，此时冒泡排序即为稳定的排序算法。

## 2.2 选择排序 (Selection Sort)

<div align="center"><img src="./assets/选择排序.gif" width="80%"></div>

- Python 版
```py
def selectSort(ary):
    n = len(ary)
    for i in range(0,n):
        index = i                             #最小元素下标标记
        for j in range(i+1,n):
            if ary[j] < ary[index] :
                index = j                     #找到最小值的下标
        ary[index],ary[i] = ary[i],ary[index]   #交换两者
    return ary
```

- Golang 版
```go
func selectSort(array []int) []int {
    for i := 0; i < len(array); i++ {
        min := i
        for j := i + 1; j < len(array); j++ {
            if array[j] < array[min] {
                min = j
            }
        }
        array[i], array[min] = array[min], array[i]
    }
    return array
}
```

- `最好情况: ` `O(n^2)`
- `最坏情况: ` `O(n^2)`
- `平均复杂度: ` `O(n^2)`
- `原地排序`
- `非稳定排序` 因为每次都要在未排序区间找到最小的值和前面的元素进行交换，这样如果遇到相同的元素，会使他们的顺序发生交换


## 2.3 快速排序 (Quick Sort)

快速排序的主要思想是通过划分将待排序的序列分成前后两部分，其中前一部分的数据都比后一部分的数据要小，然后再递归调用函数对两部分的序列分别进行快速排序，以此使整个序列达到有序。



<div align="center"><img src="./assets/快速排序.gif" width="80%"></div>

- Python 版
```py
class Solution:
    def randomized_partition(self, nums, l, r):
        pivot = random.randint(l, r)
        nums[pivot], nums[r] = nums[r], nums[pivot]
        i = l - 1
        for j in range(l, r):
            if nums[j] < nums[r]:
                i += 1
                nums[j], nums[i] = nums[i], nums[j]
        i += 1
        nums[i], nums[r] = nums[r], nums[i]
        return i

    def randomized_quicksort(self, nums, l, r):
        if r - l <= 0:
            return
        mid = self.randomized_partition(nums, l, r)
        self.randomized_quicksort(nums, l, mid - 1)
        self.randomized_quicksort(nums, mid + 1, r)

    def sortArray(self, nums: List[int]) -> List[int]:
        self.randomized_quicksort(nums, 0, len(nums) - 1)
        return nums
```

- Golang 版
```go
func sortArray(nums []int) []int {
    // 快速排序，基于比较，不稳定算法，时间平均O(nlogn)，最坏O(n^2)，空间O(logn)
    // 分治思想，选主元，依次将剩余元素的小于主元放其左侧，大的放右侧
    // 然后取主元的前半部分和后半部分进行同样处理，直至各子序列剩余一个元素结束，排序完成
    // 注意: 
    // 小规模数据(n<100)，由于快排用到递归，性能不如插排
    // 进行排序时，可定义阈值，小规模数据用插排，往后用快排
    // golang的sort包用到了快排
    // (小数，主元，大数)
    var quick func(nums []int, left, right int) []int
    quick = func(nums []int, left, right int) []int {
        // 递归终止条件
        if left > right {
            return nil
        }
        // 左右指针及主元
        i, j, pivot := left, right, nums[left]
        for i < j {
            // 寻找小于主元的右边元素
            for i < j && nums[j] >= pivot {
                j--
            }
            // 寻找大于主元的左边元素
            for i < j && nums[i] <= pivot {
                i++
            }
            // 交换i/j下标元素
            nums[i], nums[j] = nums[j], nums[i]
        }
        // 交换元素
        nums[i], nums[left] = nums[left], nums[i]
        quick(nums, left, i-1)
        quick(nums, i+1, right)
        return nums
    }
    return quick(nums, 0, len(nums)-1)
}
```

- `时间复杂度: `基于随机选取主元的快速排序时间复杂度为期望 $O(logn)$，其中 $n$ 为数组的长度。

- `空间复杂度: `$O(h)$ , 其中 $h$ 为快速排序递归调用的层数。我们需要额外的 $O(h)$ 的递归调用的栈空间，由于划分的结果不同导致了快速排序递归调用的层数也会不同，最坏情况下需 $O(n)$ 的空间，最优情况下每次都平衡，此时整个递归树高度为 $nlogn$，空间复杂度为 $O(logn)$


## 2.4 插入排序

插入排序是前面已排序数组找到插入的位置

<div align="center"><img src="./assets/插入排序.gif" width="80%"></div>

- Python 版
```py
def insertion_sort(nums):
    n = len(nums)
    for i in range(1, n):
        while i > 0 and nums[i - 1] > nums[i]:
            nums[i - 1], nums[i] = nums[i], nums[i - 1]
            i -= 1
    return nums
```

- Golang 版
```go
func sortArray(nums []int) []int {
    // 插入排序，比较交换，稳定算法，时间O(n^2)，空间O(1)
    // 0->len方向，每轮从后往前比较，相当于找到合适位置，插入进去
    // 数据规模小的时候，或基本有序，效率高
    for i:=0; i<len(nums); i++ {
        // 从后往前比较，找到位置插入
        for j:=i; j>0; j-- {
            if nums[j-1] > nums[j] {
                nums[j-1], nums[j] = nums[j], nums[j-1]
            }
        }
    }
    return nums
}
```

## 2.5 希尔排序 (Shell Sort)