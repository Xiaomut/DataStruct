**转载**

>  [C++ 空类，默认产生哪些成员函数](https://www.cnblogs.com/timesdaughter/p/6684633.html)
> [C++类的六个默认成员函数](https://blog.csdn.net/jelly_9/article/details/61193085)

- 默认构造函数
- 默认拷贝构造函数
- 默认析构函数
- 默认赋值运算符重载
-  取址（&）运算符重载
- const 修饰的取址运算符重载

​		我们先定义一个空类：

```c++
class A {
};
```

​		在经过编译器处理之后它就不再为空，编译器会自动加入一些默认的成员函数，即使在这些函数中什么也不做。编译器处理之后的类相当于：

```c++
class A {
 public:
  A();                         //构造函数
  A(const A& a);               //拷贝构造函数
  ~A();                        //析构函数
  A& operator=(const A& a);    //赋值运算符重载
  A* operator&();              //取址运算符重载
  const A* operator&() const;  //取址运算符重载
};
```

​		**注意：这些函数在我们没有显式给出时编译器会为我们自动合成。**

## 构造函数

​		它是一个特殊的成员函数，函数名与类名相同，无返回值，在创建对象时由编译器自动调用，以保证每个对象都有一个合适的初始值。在该对象的整个生命周期内只被调用一次。

​		**初始化列表** 用于对对象成员进行初始化，格式为在函数名和函数体之间，以一个冒号开始，后面跟着以逗号隔开的数据成员列表，在每个成员后接一个圆括号，括号中为初始化的内容。

​		**数据成员初始化顺序** 即使初始化列表中的成员顺序与定义顺序不同，初始化顺序实际也与数据成员定义的顺序一致。我们注意到，编译器在底层处理初始化列表时，是根据成员的实际定义顺序来一一初始化的。

​		**系统默认合成的构造函数** 默认构造函数使用与成员变量初始化相同的规则初始化成员，对于内置类型和复合类型的成员，如数组、指针，只对定义在全局作用域的对象初始化，对于局部作用域的内置和复合类型不作初始化。

​		**关键字 expilcit** explicit（明确的）关键字可以阻止构造函数对类型的转换。

## 拷贝构造函数

​		函数名与类名相同，无返回值，有一个形参(常用 const 修饰)，**该参数是本类类型的引用。是构造函数的重载**，通过已经存在的对象来创建并初始化对象。

**使用场景**

- 使用已经存在的对象创建新的对象

```c++
Time t1(12,01,59);
Time t2(t1);
```

- 传值方式 作为函数的参数

```c++
void FunTest1(const Time t)
{}
```

- 传值方式 作为函数返回值

```c++
Time FunTest2() {
    Time t;
    return t;
}
```

## 析构函数

​		析构函数(destructor) 与构造函数相反，当对象脱离其作用域时（例如对象所在的函数已调用完毕），系统自动执行析构函数。
​		析构函数往往用来做“清理善后” 的工作（例如在建立对象时用 new 开辟了一片内存空间，应在退出前在析构函数中用 delete 释放）。析构函数在对象生命周期结束前由系统自动调用。

**析构函数在对象生命周期结束前由系统自动调用。**

## 赋值操作符（=）重载

​		普通类型之间的赋值通过简单的 `=` 完成。