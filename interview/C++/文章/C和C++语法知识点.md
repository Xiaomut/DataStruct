*这里面记录的知识点都是在牛客网做C++题目的过程中遇到的，体系可能不够全面，各部分的分割j基本是按照《C++ Prime第五版》组织的，文章的内容基本上是抄录的题的讨论，不是原创，但基本都是引用的《C++ Prime》中的*

---

# 1 变量和基本类型

## 静态变量在整个程序的运行过程中始终是存在的

static变量存放在程序的初始化全局变量区，生命周期与全局变量相同，从程序开始就分配空间并初始化，到程序结束空间被释放。但static变量的作用域并不等同于生命周期，如果static变量在局部作用域内声明，则只可以在局部作用域内被调用。

## 指针

```c++
char (*p)[16];  // p是指向长度为16的字符数组的指针
```

## c 中的基本数据类型

c 中的基本数据类型只有整型，实型，字符型

在C中没有逻辑型数据，在逻辑运算结果中以“1”代表“真”，以“0”代表“假”；在逻辑判断中，以“非0”代表“真”，以“0”代表“假”。

在C++中有逻辑型数据，以“true”代表“真”，以“false”代表“假”。

## 隐含存储类型

函数的隐含储存类型是 extern,函数的形参或变量的储存类型为 auto

---

# 2 字符串 向量 数组



---

## 二维数组初始化

**二维数组必须指定列的数量，行的数量可以不指定，二维数组的初始化方式有以下几种：**

**⑴ 分行进行初始化** 
`int a[2][3]={{1,2,3},{4，5，6}}; `
在{ }内部再用{ }把各行分开，第一对{ }中的初值1，2，3是0行的3个元素的初值。第二对{ }中的初值4，5，6是1行的3个元素的初值。相当于执行如下语句： 
`int a[2][3]；` 
`a[0][0]=1；a[0][1]=2；a[0][2]=3；a[1][0]=4；a[1][1]=5；a[1][2]=6；` 
注意，初始化的数据个数不能超过数组元素的个数，否则出错。 
**⑵ 不分行的初始化** 
`int a[2][3]={ 1,2，3，4，5，6};` 
把{ }中的数据依次赋给a数组各元素（按行赋值）。即a[0][0]=1; a[0][1]=2；a[0][2]=3；a[1][0]=4；`a[1][1]=5；a[1][2]=6；` 
**⑶ 为部分数组元素初始化** 
`static int a[2][3]={{1,2},{4}}; `
第一行只有2个初值，按顺序分别赋给a[0][0]和a[0][1]；第二行的初值4赋给a[1][0]。由于存储类型是static，故其它数组元素的初值为0。注：某些C语言系统（如：Turbo C）中，存储类型不是static的变量或数组的初值也是0。 
`static int a[2][3]={ 1,2}; `
只有2个初值，即a[0][0]=1，a[0][1]=2，其余数组元素的初值均为0。 
**⑷ 可以省略第一维的定义，但不能省略第二维的定义。系统根据初始化的数据个数和第2维的长度可以确定第一维的长度。** 
`int a[ ][3]={ 1,2，3，4，5，6}; `
a数组的第一维的定义被省略，初始化数据共6个，第二维的长度为3，即每行3个数，所以a数组的第一维是2。 
一般，省略第一维的定义时，第一维的大小按如下规则确定： 
初值个数能被第二维整除，所得的商就是第一维的大小；若不能整除，则第一维的大小为商再加1。例如，`int a[ ][3]={ 1,2，3，4};等价于：int a[2][3]={ 1,2，3，4}; `
若分行初始化，也可以省略第一维的定义。下列的数组定义中有两对{ }，已经表示a数组有两行。 
`static int a[ ][3]={{1,2},{4}};`

## 数组

数组名的值是一个指针常量，也就是数组第一个元素的地址

`int s[3][3],(*p)[3];p=s;`
`数组指针指向数组的首地址，p指向s[0][0]，s[i][j]==*(*(p+i)+j)`

# 3 表达式



---

# 4 语句



---

# 5 函数

## 重载函数

只有函数名，形参个数，形参类型可以区分重载函数

## C语言函数调用

```c
int main(){
    char s[] = "123";
    p = s;
    printf("%c%c%c", *p++, *p++, *p++);
}
```

`printf()`函数中的表达式从右向左计算，首先要搞清楚(*p++)中++的优先级高于*;其次参数从右往左入栈，最后一个(*p++)的值为1入栈，然后第二个(*p++)的值为2入栈，最后第一个(*p++)的值为3入栈，打印的时候就是出栈的过程，后入先出，结果为321  

---

# 6 类

## 派生类中构造函数的调用顺序

- 构造函数调用顺序：基类构造函数->子类成员变量构造函数->子类构造函数   
- 析构函数调用顺序：子类析构函数->子类成员变量析构函数->基类析构函数  
- 组合派生类的构造函数构造顺序为：初始化基类成员->初始化新增对象成员->初始化新增非对象成员
- 同时组合派生类具有多个新增对象成员的时候，按照类中的声明顺序来初始化对象成员。

## 派生类的访问特性

- 派生类的非静态成员函数能在函数体内访问this指向的自身对象的基类受保护成员 
- 派生类的静态函数和友元可以通过派生类的对象来访问此对象的基类受保护成员 
- 派生类的静态函数和友元不能通过基类对象来访问此对象的受保护成员

## 虚函数表

[对虚函数表的剖析](<https://blog.csdn.net/haoel/article/details/1948051>)

## 必须要通过初始化列表来初始化的内容

引用，const成员变量，基类构造函数 一定要通过初始化列表来实现。 static类型不是类对象成员，不需要通过初始化列表来初始化

---

# 7 STL



---

# 8 动态内存

## 如和让类对象只能在栈/堆上分配空间

[详细说明](<https://blog.csdn.net/hxz_qlh/article/details/13135433>)



---

# 9 拷贝控制



---

# 10 操作符重载和类型转换

## 不能被重载的运算符

- `.`(成员访问运算符) 
- `*`(成员指针访问运算符) 
- `::` (域运算符) 
- `sizeof`(长度运算符)
-  `? :` (条件运算符）

## 自增自减运算符的重载

`++`和`--`有前缀和后缀两种形式，为了区分，要求在后缀形式加一个`int`参数。  `const Fraction operator ++(int)` 中 `int`不过是个哑元（dummy）,是永远用不上的，它只是用来判断`++`是prefix  还是 postfix  。如果有哑元，则是postfix,否则，就是prefix 。 

---

# 11 模板和泛型编程



---

# 12 基本函数

## printf()

[详细介绍见此博客](<https://www.cnblogs.com/renxinyuan/p/3862772.html>)

## read()

```c++
ssize_t  read(int filedes, void *buf, size_t nbytes);
// 能够从输入流提取指定长度的字节序列
```

## clone() 与 fork()

fork() 函数复制时将父进程的所以资源都通过复制数据结构进行了复制，然后传递给子进程，所以 fork() 函数不带参数； clone() 函数则是将部分父进程的资源的数据结构进行复制，复制哪些资源是可选择的，这个可以通过参数设定，所以 clone() 函数带参数，没有复制的资源可以通过指针共享给子进程 。另外，clone()返回的是子进程的pid。

## fclose()

 `fclose`是一个函数名，功能是关闭一个流。使用`fclose()`函数就可以把缓冲区内最后剩余的数据输出到内核缓冲区，并释放文件指针和有关的缓冲区.函数原型：
`int fclose( FILE *fp )`
一次正常的`fclose`会争取释放FILE指针的相关内容。再次`fclose`释放已经释放掉了的FILE指针，所以会出错

---

# 13 预处理，编译，链接，运行

## 编译与链接

编译时只是把函数的符号地址记录下来，链接时该函数符号有定义才会变成具体的地址。如果链接过程中所有符号都有定义，链接成功，生成可执行文件；否则链接失败。

## extern关键字

假设某C工程包含a.c和b.c两个文件,在a.c中定义了一个全局变量foo, 在b.c中想访问这一变量时该怎么做?

b.c中声明时extern int foo (和其他语言中的import很相似)

## 宏定义

宏定义只是简单的进行代码替换，而不会进行任何运算

```c++
# define add(x, y) x + y

i = 5;
result = i * add(i, i) // 预处理过程中变成 result = i * i + i
```

## 编译器的优化编译

```c++
const int i = 0; 
int *j = (int *) &i; 
*j = 1; 
printf("%d,%d", i, *j);
// 问输出为多少？
```

输出为0， 1；

但是在c编译器和c++编译器下，此结果不一样。c中答案为`1 1`，c++中为`0 1`。
解释：

c语言中的const是运行时const，编译时只是定义，在运行时只会初始化。C语言中const变量不能用于成为数组长度等作为编译时常量的情况，原因就在此。C语言const变量在运行时改变了是可以再次读出改变后的值的。

c++中，const变量是编译时的常量，可以向#define定义的常量一样使用。故C++中const变量的值在编译时就已经确定了，直接对cosnt变量进行了值的替换，因此当const变量的值改变时，const的变量值是不会得到更新的。const变量（即常量）值 **放在编译器的符号表中** ，计算时编译器直接从表中取值，省去了访问内存的时间，从而达到了优化。

---

# 14 关键字

## new创建类对象

**一、new创建类对象与不new区别**

下面是自己总结的一些关于new创建类对象特点：

- new创建类对象需要指针接收，一处初始化，多处使用
- new创建类对象使用完需delete销毁
- new创建对象直接使用堆空间，而局部不用new定义类对象则使用栈空间
- new对象指针用途广泛，比如作为函数返回值、函数参数等
- 频繁调用场合并不适合new，就像new申请和释放内存一样

**new**创建类对象实例

1、new创建类对象例子：

CTest* pTest = new CTest();
delete pTest;
pTest用来接收类对象指针。
不用new，直接使用类定义申明：
CTest mTest;

此种创建方式，使用完后不需要手动释放，该类析构函数会自动执行。而new申请的对象，则只有调用到delete时再会执行析构函数，如果程序退出而没有执行delete则会造成内存泄漏。

2、只定义类指针
这跟不用new申明对象有很大区别，类指针可以先行定义，但类指针只是个通用指针，在new之前并为该类对象分配任何内存空间。比如：
CTest* pTest = NULL;

但使用普通方式创建的类对象，在创建之初就已经分配了内存空间。而类指针，如果未经过对象初始化，则不需要delete释放。

3、new对象指针作为函数参数和返回值

## const

`int const *a` 和 `const int *a`意义相同，作用等价
`const int *a`  这里`const` 修饰的是`int`，而`int`定义的是一个整值
`int *const a`   这里`const`修饰的是 a ，a代表的是一个指针地址  因此不能赋给a其他的地址值，但可以修改a指向的值
`const int * const a`  这个代表a所指向的对象的值以及它的地址本身都不能被改变

## static

static变量 ：程序再次调用时static变量的值不会重新初始化，而是在上一次退出时的基础上继续执行。

---

# 15 平台相关知识

## C++字节对齐的知识

[参考此篇博客](<https://blog.csdn.net/sweetfather/article/details/78487563>)

// 对齐原则：每一成员需对齐为后一成员类型的倍数
// 补齐原则：最终大小补齐为成员类型最大值的倍数

```c++
structA {
 	inta;     // 4
 	shortb;   // (4) + 2 = 6 下一元素为 int，需对齐为4的倍数,6+(2) = 8
 	intc;     // (8) + 4 = (12)
 	chard;    // (12) + 1 = 13， 需补齐为4的倍数，13 + (3) = 16
};

structB {
 	inta;     // 4
 	shortb;   // (4) + 2 = 6，下一成员为 char 类型，不考虑对齐
 	charc;    // (6) + 1 = 7，下一成员为int类型，需对其为4的倍数，7+(1) = 8
 	intd;     // (8) + 4 = 12，已是 4 的倍数
}
```

不同的数据类型在32位和64位下所占字节的区别
32位编译器：
	char ：1个字节
	char*（即指针变量）: 4个字节（32位的寻址空间是2^32, 即32个bit，也就是4个字节。同理64位编译器）
      short int : 2个字节
      int： 4个字节
      unsigned int : 4个字节
      float: 4个字节
      double: 8个字节
      long: 4个字节
      long long: 8个字节
      unsigned long: 4个字节
64位编译器：
	 char ：1个字节
      char*(即指针变量): 8个字节
​      short int : 2个字节
​     int： 4个字节
​      unsigned int : 4个字节
​      float: 4个字节
​      double: 8个字节
​      long: 8个字节
​      long long: 8个字节

​      unsigned long: 8个字节