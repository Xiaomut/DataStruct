**转载**

> [C++ 内存对齐](https://www.cnblogs.com/TenosDoIt/p/3590491.html)

_原作者注：本文代码测试环境为win7 X64 cpu, 编译器为gcc4.7.1 和 vs2010_

_我自己的测试环境是 GCC 9.1, 和原作者有不同结果的时候会标注出来_

---

内存对齐是编译器为了便于 CPU 快速访问而采用的一项技术

我们先从一个例子开始，对下面的类(或者结构体)

```c++
class node {
    char c;
    int i;
    short s;
}no;
```

sizeof(no)的值是多少呢，如果你的回答是7(1+4+2)，那么你应该认真阅读下面的内容。可以在编译器上试试，输出的结果是12，这就是内存对齐的结果。

**为什么要进行内存对齐呢？**

1. 平台原因(移植原因)：不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。
2. 性能原因：数据结构(尤其是栈)应该尽可能地在自然边界上对齐。原因在于，为了访问未对齐的内存，处理器需要作两次内存访问；而对齐的内存访问仅需要一次访问。

编译器一般按照几个字节对齐呢？本文中两个编译器**默认按照类中最大类型长度来对齐**，我么也可以使用语句 `#pragma pack(i)(i = 1,2,4,8,16)` 来设置对齐字节数目，VS 还可以在项目属性 -> 配置属性 -> C/C++ -> 代码生成 -> 结构成员对齐设置。

**对齐规则如下**

1. 如果设置了内存对齐为 i 字节，类中最大成员对齐字节数为 j，那么整体对齐字节n = min(i, j)  （某个成员的对齐字节数定义：如果该成员是 C++ 自带类型如 int、char、double 等，那么其对齐字节数等于该类型在内存中所占的字节数；如果该成员是自定义类型如某个 class 或者 struct，那个它的对齐字节数等于该类型内最大的成员对齐字节数《详见实例4》）
2. 每个成员对齐规则：类中第一个数据成员放在 offset 为 0 的位置；对于其他的数据成员（假设该数据成员对齐字节数为 k ），他们放置的起始位置 offset 应该是 min(k, n) 的整数倍
3. 整体对齐规则：最后整个类的大小应该是 n 的整数倍
4. 当设置的对齐字节数大于类中最大成员对齐字节数时，这个设置实际上不产生任何效果（实例2）；当设置对齐字节数为 1 时，类的大小就是简单的把所有成员大小相加

我们通过以下几个实例来分析

**实例1**：（没有指定对齐字节，则n = 最大成员（int i）的大小4）

```c++
class node {
    char c;   //放在位置0，位置区间[0]
	int i;      //4 = n, 那么放置起始位置应该是4的倍数，即4，位置区间为[4~7]
	short s; //2 < n，那么放置起始位置应该是2的倍数，即8，位置区间为[8~9]
};
```

此时成员共占用[0~9]10个字节，还要整体对齐，大小应该是4的倍数，即12

**实例2**：（假设指定对齐字节为8，那么n = min(8,4) = 4）

```c++
#pragma pack(8)

class node {
    int i; //放在位置0，位置区间[0~3]
	char c; //1 < n, 那么放置起始位置应该是1的倍数，即4，位置区间为[4]
	short s; //2 < n，那么放置起始位置应该是2的倍数，即6，位置区间为[6~7]
};
```

成员共占据[0~7]8个字节，刚好是4的倍数，因此大小是8

**实例3**：（假设指定对齐字节是2，则n = min(2,4) = 2）

```c++
#pragma pack(2)

class node {
    char c; //放在位置0，位置区间[0]
	int i; //4 > n, 那么放置起始位置应该是2的倍数，即2，位置区间为[2~5]
	short s; //2 = n，那么放置起始位置应该是2的倍数，即6，位置区间为[6~7]
};
```

此时成员共占用[0~7]8个字节，刚好是4的倍数，因此大小是8

**实例4**：（按照默认设置）

```c++
class temp 
{ 
    char c; 
    int i; 
    short s1; 
};
```

由实例1可知，默认对齐情况下，temp的大小是12，temp的对齐字节数是：三个成员取最大的，即为4；

对于node，n = 其三个成员对齐字节数取最大，即等于t的对齐字节数，也就是 4。

```c++
class node {
    char c; //放在位置0，位置区间[0]
	temp t; //4（temp的对齐字节数） = n, 那么放置起始位置应该是4的倍数，即4，位置区间为[4~15]
	short s; //2 < n，那么放置起始位置应该是2的倍数，即16，位置区间为[16~17]
};
```

此时成员共占用[0~17]18个字节，还要整体对齐，大小应该是4的倍数，因此大小是20

**实例5**：（默认设置）

对于node，n = 其三个成员对齐字节数取最大，即等于d的对齐字节数，也就是 8。

```c++
class node {
    temp t; //放在位置0，位置区间[0~11]
	double d; //8（temp的对齐字节数） = n, 那么放置起始位置应该是8的倍数，即16，位置区间为[16~23]
	short s; //2 < n，那么放置起始位置应该是2的倍数，即24，位置区间为[24~25]
};
```

此时成员共占用[0~25]26个字节，还要整体对齐，大小应该是8的倍数，因此大小是32.

**类继承时的内存对齐**

考虑如下类

```c++
class A	 {
    int i;
    char c1;
};

class B: public A {
    char c2;
};

class C: public B {
    char c3;
};
```

sizeof(C)结果是多少呢，gcc和vs给出了不同的结果，分别是8、16

gcc中：C相当于把所有成员i、c1、c2、c3当作是在一个class内部，(先继承后对齐)

vs中：对于A，对齐后其大小是8；对于B，c2加上对齐后的A的大小是9，对齐后就是12；对于C，c3加上对齐后的B大小是13，再对齐就是16 (先对齐后继承)

关于c++对象继承后的内存布局，更详细的分析可以《深度探索参考c++对象模型》第三章。