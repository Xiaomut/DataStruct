**参考**

> [浅谈C++多态性](https://blog.csdn.net/hackbuteer1/article/details/7475622)

​		多态性可以简单地概括为“一个接口，多种方法”，程序在运行时才决定调用的函数，它是面向对象编程领域的核心概念。

​		C++ 多态性是通过虚函数来实现的，虚函数允许子类重新定义成员函数，而子类重新定义父类的做法称为覆盖(override)，或者称为重写。

​		而重载则是允许有多个同名的函数，而这些函数的参数列表不同，允许参数个数不同，参数类型不同，或者两者都不同。编译器会根据这些函数的不同列表，将同名的函数的名称做修饰，从而生成一些不同名称的预处理函数，来实现同名函数调用时的重载问题。但这并没有体现多态性。

​		多态与非多态的实质区别就是函数地址是早绑定还是晚绑定。如果函数的调用，在编译器编译期间就可以确定函数的调用地址，并生产代码，是静态的，就是说地址是早绑定的。而如果函数调用的地址不能在编译期间确定，需要在运行时才确定，这就属于晚绑定。

​		封装可以使得代码模块化，继承可以扩展已存在的代码，他们的目的都是为了代码重用。而多态的目的则是为了接口重用。也就是说，不论传递过来的究竟是那个类的对象，函数都能够通过同一个接口调用适应各自对象的实现方法。

​		**多态最常见的用法就是声明基类的指针，利用该指针指向任意一个子类对象，调用相应的虚函数，可以根据指向的子类的不同而调用不同的方法。如果没有使用虚函数的话，即没有利用 C++ 多态性，则利用基类指针调用相应的函数的时候，将总被限制在基类函数本身，而无法调用到子类中被重写过的函数。因为没有多态性，函数调用的地址将是一定的，而固定的地址将始终调用到同一个函数，这就无法实现一个接口，多种方法的目的了。**

```c++
#include <iostream>
using namespace std;

class Base {
public:
    void func1() {
        cout << "Base::func1()" << endl;
    }
    virtual void func2() {
        cout << "Base::func2()" << endl;
    }
};

class Derived : public Base {
public:
    void func1() {
        cout << "Derived::func1()" << endl;
    }
    void func2() {
        cout << "Derived::func2()" << endl;
    }
};

int main() {
    Base b;
    Derived d;
    Base* bp = &b;
    
    bp->func1();  // Base::func1()
    bp->func2();  // Base::func2()
    
    bp = &d;
    bp->func1();  // Base::func1()
    bp->func2();  // Derived::func2()
    
    return 0;
}
```

第一组 `bp->func1();` 和 `bp->func2();` 很好理解，本身是基类指针，指向的又是基类对象，调用的都是基类本身的函数。

第二组中 `bp->func1();` 和 `bp->func2();` 则是基类指针指向子类对象，正式体现多态的用法。 `bp->func1();` 由于指针是个基类指针，指向的是一个固定偏移量的函数，因此此时指向的就只能是基类的 `func1()` 函数的代码了，因此输出的结果还是 ` Base::func1()`。而 `bp` 是基类指针，指向的`fun2()`是一个虚函数，由于每个虚函数都有一个虚函数列表，此时 `bp` 调用 `fun2()` 并不是直接调用函数，而是通过虚函数列表找到相应的函数的地址，因此根据指向的对象不同，函数地址也将不同，这里将找到对应的子类的 `fun2()` 函数的地址，因此输出的结果也会是子类的结果`Derived::func2()`。

**C++纯虚函数**

**一、定义**
  纯虚函数是在基类中声明的虚函数，它在基类中没有定义，但要求任何派生类都要定义自己的实现方法。在基类中实现纯虚函数的方法是在函数原型后加“=0” 

```c++
 virtual void funtion()=0 
```

**二、引入原因**
   1、为了方便使用多态特性，我们常常需要在基类中定义虚拟函数。 
   2、在很多情况下，基类本身生成对象是不合情理的。例如，动物作为一个基类可以派生出老虎、孔雀等子类，但动物本身生成对象明显不合常理。 
  为了解决上述问题，引入了纯虚函数的概念，将函数定义为纯虚函数，则编译器要求在派生类中必须予以重写以实现多态性。同时含有纯虚拟函数的类称为抽象类，它不能生成对象。这样就很好地解决了上述两个问题。

**三、相似概念**
   1、多态性
  指相同对象收到不同消息或不同对象收到相同消息时产生不同的实现动作。C++支持两种多态性：编译时多态性，运行时多态性。 

- 编译时多态性：通过重载函数实现

- 运行时多态性：通过虚函数实现。 

2、虚函数 
虚函数是在基类中被声明为 virtual，并在派生类中重新定义的成员函数，可实现成员函数的动态覆盖（Override）
3、抽象类 
包含纯虚函数的类称为抽象类。由于抽象类包含了没有定义的纯虚函数，所以不能实例化抽象类的对象。

