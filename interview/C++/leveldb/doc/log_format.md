# leveldb Log format

日志文件内容是32KB块的序列。 唯一的例外是文件的尾部可能包含部分块。 每个块由一系列记录组成：

```
    block := record* trailer?
    record :=
      checksum: uint32     // crc32c of type and data[] ; little-endian
      length: uint16       // little-endian
      type: uint8          // One of FULL, FIRST, MIDDLE, LAST
      data: uint8[length]
```

记录永远不会在块的最后六个字节内开始（因为它不适合）。 这里的任何剩余字节构成预告片，它必须完全由零字节组成，读取的时候必须跳过它。

另外：如果当前块中只剩下7个字节，并且添加了新的非零长度记录，则writer必须发出FIRST记录（其中包含零字节的用户数据）以填充块的尾随7个字节 然后在后续块中发出（记录）所有用户数据。

将来可能会添加更多类型。 某些读者可能会跳过他们不理解的记录类型，其他人可能会报告某些数据被跳过。

```
FULL == 1
FIRST == 2
MIDDLE == 3
LAST == 4
```

FULL记录包含整个用户记录的内容。 FIRST，MIDDLE，LAST是用于已分割成多个片段的用户记录的类型（通常由于块边界）。 FIRST是用户记录的第一个片段的类型，LAST是用户记录的最后一个片段的类型，MIDDLE是用户记录的所有内部片段的类型。

示例：考虑如下一系列用户记录：

```
A: length 1000
B: length 97270
C: length 8000
```

**A**将作为FULL记录存储在第一个块中。 

**B **将被分成三个片段：第一个片段占据第一个块的剩余部分，第二个片段占据第二个块的整体，第三个片段占据第三个块的前缀。 这将在第三个块中留下六个字节空闲，这将作为预告片留空。

 **C**将作为FULL记录存储在第四个块中。

## 与recordio格式相比的一些好处：

1.我们不需要任何启发式重新同步 - 只需转到下一个块边界并扫描。 如果存在损坏，则跳至下一个块。 作为一个附带好处，当一个日志文件的部分内容作为记录嵌入到另一个日志文件中时，我们不会感到困惑。

 2.在近似边界处分割（例如，对于mapreduce）很简单：找到下一个块边界并跳过记录，直到我们达到FULL或FIRST记录。

 3.对于大型记录，我们不需要额外的缓冲。

## 与recordio格式相比的一些缺点：

1.没有微小的记录。 这可以通过添加新记录类型来修复，因此它是当前实现的缺点，不一定是格式。 

2.没有压缩。 同样，这可以通过添加新记录类型来修复。